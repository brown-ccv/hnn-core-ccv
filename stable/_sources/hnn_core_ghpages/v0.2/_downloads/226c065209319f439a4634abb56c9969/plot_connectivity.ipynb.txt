{
  "cells": [
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "collapsed": false
      },
      "outputs": [],
      "source": [
        "%matplotlib inline"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "\n# 03. Modifying local connectivity\n\nThis example demonstrates how to modify the network connectivity.\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "collapsed": false
      },
      "outputs": [],
      "source": [
        "# Author: Nick Tolley <nicholas_tolley@brown.edu>\n\n# sphinx_gallery_thumbnail_number = 2\n\nimport os.path as op"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Let us import ``hnn_core``.\n\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "collapsed": false
      },
      "outputs": [],
      "source": [
        "import hnn_core\nfrom hnn_core import jones_2009_model, simulate_dipole"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "To explore how to modify network connectivity, we will start with simulating\nthe evoked response from the\n`evoked example <sphx_glr_auto_examples_plot_simulate_evoked.py>`, and\nexplore how it changes with new connections. We first instantiate the\nnetwork. (Note: Setting ``add_drives_from_params=True`` loads a set of\npredefined drives without the drives API shown previously).\n\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "collapsed": false
      },
      "outputs": [],
      "source": [
        "net_erp = jones_2009_model(add_drives_from_params=True)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Instantiating the network comes with a predefined set of connections that\nreflect the canonical neocortical microcircuit. ``net.connectivity``\nis a list of dictionaries which detail every cell-cell, and drive-cell\nconnection. The weights of these connections can be visualized with\n:func:`~hnn_core.viz.plot_connectivity_weights` as well as\n:func:`~hnn_core.viz.plot_cell_connectivity`. We can search for specific\nconnections using ``pick_connection`` which returns the indices\nof ``net.connectivity`` that match the provided parameters.\n\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "collapsed": false
      },
      "outputs": [],
      "source": [
        "from hnn_core.viz import plot_connectivity_matrix, plot_cell_connectivity\nfrom hnn_core.network import pick_connection\n\nprint(len(net_erp.connectivity))\n\nconn_indices = pick_connection(\n    net=net_erp, src_gids='L5_basket', target_gids='L5_pyramidal',\n    loc='soma', receptor='gabaa')\nconn_idx = conn_indices[0]\nprint(net_erp.connectivity[conn_idx])\nplot_connectivity_matrix(net_erp, conn_idx)\n\ngid_idx = 11\nsrc_gid = net_erp.connectivity[conn_idx]['src_gids'][gid_idx]\nfig = plot_cell_connectivity(net_erp, conn_idx, src_gid)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Data recorded during simulations are stored under\n:class:`~hnn_core.Cell_Response`. Spiking activity can be visualized after\na simulation is using :meth:`~hnn_core.Cell_Response.plot_spikes_raster`\n\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "collapsed": false
      },
      "outputs": [],
      "source": [
        "dpl_erp = simulate_dipole(net_erp, tstop=170., n_trials=1)\nnet_erp.cell_response.plot_spikes_raster()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can also define our own connections to test the effect of different\nconnectivity patterns. To start, ``net.clear_connectivity()`` can be used\nto clear all cell-to-cell connections. By default, previously defined drives\nto the network are retained, but can be removed with ``net.clear_drives()``.\n``net.add_connection`` is then used to create a custom network. Let us first\ncreate an all-to-all connectivity pattern between the L5 pyramidal cells,\nand L2 basket cells. :meth:`hnn_core.Network.add_connection` allows\nconnections to be specified with either cell names, or the cell IDs (gids)\ndirectly.\n\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "collapsed": false
      },
      "outputs": [],
      "source": [
        "def get_network(probability=1.0):\n    net = jones_2009_model(add_drives_from_params=True)\n    net.clear_connectivity()\n\n    # Pyramidal cell connections\n    location, receptor = 'distal', 'ampa'\n    weight, delay, lamtha = 1.0, 1.0, 70\n    src = 'L5_pyramidal'\n    for target in ['L5_pyramidal', 'L2_basket']:\n        net.add_connection(src, target, location, receptor,\n                           delay, weight, lamtha, probability=probability)\n\n    # Basket cell connections\n    location, receptor = 'soma', 'gabaa'\n    weight, delay, lamtha = 1.0, 1.0, 70\n    src = 'L2_basket'\n    for target in ['L5_pyramidal', 'L2_basket']:\n        net.add_connection(src, target, location, receptor,\n                           delay, weight, lamtha, probability=probability)\n    return net\n\n\nnet_all = get_network()\ndpl_all = simulate_dipole(net_all, tstop=170., n_trials=1)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can additionally use the ``probability`` argument to create a sparse\nconnectivity pattern instead of all-to-all. Let's try creating the same\nnetwork with a 10% chance of cells connecting to each other.\n\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "collapsed": false
      },
      "outputs": [],
      "source": [
        "net_sparse = get_network(probability=0.1)\ndpl_sparse = simulate_dipole(net_sparse, tstop=170., n_trials=1)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "With the previous connection pattern there appears to be synchronous rhythmic\nfiring of the L5 pyramidal cells with a period of 10 ms. The synchronous\nactivity is visible as vertical lines where several cells fire simultaneously\nUsing the sparse connectivity pattern produced a lot more spiking in\nthe L5 pyramidal cells.\n\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "collapsed": false
      },
      "outputs": [],
      "source": [
        "net_all.cell_response.plot_spikes_raster()\nnet_sparse.cell_response.plot_spikes_raster()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can plot the sparse connectivity pattern between cell populations.\n\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "collapsed": false
      },
      "outputs": [],
      "source": [
        "conn_indices = pick_connection(\n    net=net_sparse, src_gids='L2_basket', target_gids='L2_basket',\n    loc='soma', receptor='gabaa')\n\nconn_idx = conn_indices[0]\nplot_connectivity_matrix(net_sparse, conn_idx)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Note that the sparsity is in addition to the weight decay with distance\nfrom the source cell.\n\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "collapsed": false
      },
      "outputs": [],
      "source": [
        "src_gid = net_sparse.connectivity[conn_idx]['src_gids'][5]\nplot_cell_connectivity(net_sparse, conn_idx, src_gid=src_gid)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "In the sparse network, there still appears to be some rhythmicity\nwhere the cells are firing synchronously with a smaller period of 4-5 ms.\nAs a final step, we can see how this change in spiking activity impacts\nthe aggregate current dipole.\n\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {
        "collapsed": false
      },
      "outputs": [],
      "source": [
        "import matplotlib.pyplot as plt\nfrom hnn_core.viz import plot_dipole\nfig, axes = plt.subplots(2, 1, sharex=True, figsize=(6, 6),\n                         constrained_layout=True)\n\nwindow_len = 30  # ms\nscaling_factor = 3000\ndpls = [dpl_erp[0].smooth(window_len).scale(scaling_factor),\n        dpl_all[0].smooth(window_len).scale(scaling_factor),\n        dpl_sparse[0].smooth(window_len).scale(scaling_factor)]\n\nplot_dipole(dpls, ax=axes[0], layer='agg', show=False)\naxes[0].legend(['Default', 'Custom All', 'Custom Sparse'])\nnet_erp.cell_response.plot_spikes_hist(\n    ax=axes[1], spike_types=['evprox', 'evdist'])"
      ]
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.8.10"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}